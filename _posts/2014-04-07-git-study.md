---
layout: article
title: git笔记
---
Linus Torvalds创造了这个星球上两个了不起的工具，一个是linux,另一个就是git,这两个东西也许会伴随我等小小程序员一生，你说人家怎么挥手就是伟大的作品？任何一个有点追求的程序员都应该学习git，就像学习linux一样。

###什么是git
感谢一个开发BitKeeper软件的商业公司，这个软件最初被Linus用来管理linux的内核,但是有一天那个商业公司收回了软件的免费使用权，linus一气之下大手一挥，于是git诞生了，它追求速度，简单，强力支持非线性开发，分布式，可管理Linux内内核级别项目。
出自大师之手，同时支撑了linux的开发，它不火都不可能，git的特点需要和传统版本控制系统比较才体现得出来。

那么git真的是一个版本控制软件吗？潜意识，我们认为的版本控制软件是管理了每个文件的变化的，可git不是，git不管理文件的变化，它其实本质似乎是一个微型文件系统，通过这个文件系统和一系列工具外在表现成了一个版本控制软件，我们的程序每一次的提交都被git快照保存了起来。
每次提交以来于一系列指纹信息来定位，所以理解了git其实是一个文件系统就能很好理解git和其他真正版本控制软件比如svn的区别。


###git如何保存数据
假设我们有个目录里面保存了三个文件，这个目录和文件组成了一个tree，那么保存进git也是一个tree，不过git不记文件名，它只用目录或者文件的sha1摘要来定位，每个文件对应一个blob对象，由于不记住文件名，所以如果两个文件内容完全一样，那么他们在git中共享一个blob对象，tree的sha1是计算
每个目录的sha1得到的，每次提交就是提交者个tree，tree上关联了blob，每次提交保存了提交信息，这些信息保存在了叫做commit对象中，所以就我们刚才这个目录为例子，会得到这样一个保存模型：
![git保存图](/images/git_save.jpg)


###初始版本库
创建一个目录，比如gitstudy，要让这个目录是git可管理的，cd进去，然后git init:
{% highlight bash %}
mkdir gitstudy
cd gitstudy
git init
{% endhighlight %}
这个时候会生成一个.git目录，这就是git的工作目录，所有的git信息都记录在了里面，至于这个目录里面到底是些什么东西，这就涉及到git的原理了，我会在文章最后道出。

如果希望这个库是一个共享库，不在这里编辑文件，需要用git init --bare命令进行初始化，这样得到的库是没有工作目录的。

###开始git
为了便于我们理解整个过程，我们把文件名取得简单点，同时文件内容用数字，这样可以非常明显的跟踪变化，先创建两个文件a,b，两个文件的内容都是数字1
{% highlight bash %}
vi a #写入数字1
vi b #写入数字1
git status
git add a b
git commit -m "1"
{% endhighlight %}

vi创建的文件放在了git的工作目录，我们通过git status可看到a,b文件处于Untracked即未跟踪状态。git add a b命令将文件变为跟踪状态，git叫做stage暂存状态，这里是一个缓存区，git commit就是对缓存区的文件进行提交,-m是写入提交的comments。

ok，这样就完成了一个版本控制软件的基本使用，要查看日志使用git log，会得到下面的日志:
{% highlight bash %}
commit 2e35f384605ce666deff3ef49e9e953aeaf7d5f7
Author: vsmysee <vsmysee@gmail.com>
Date:   Mon Apr 7 01:00:59 2014 +0800

    1
{% endhighlight %}
git的每次提交都会得到一个SHA1指纹，这个指纹相当的重要，大量的命令依赖于它。最后一行是提交的comments。

要学会以各种方式查看log，上面默认的显示方式可能太占用空间，我们可以用:
{% highlight bash %}
git log --pretty=oneline
git log --pretty=format:"%h - %an, %ar : %s"
git log --pretty=format:"%h %s" --graph #这个可以看到简单的分支演化
gitk #以图形化方式呈现
{% endhighlight %}

###撤销
我们不可能不犯错，那么怎么在git中拯救我们的错误呢？git的文件状态如下：
{% highlight bash %}
1，untracked 未跟踪，这种文件没有被git管理起来 git add可转化为staged
2，staged 已暂存，表示准备提交
3，modified，已修改，git add 可转化为staged
4，committed，已提交，表示已安全的保存在本地数据库了
{% endhighlight %}
其实你在执行每个命令的时候，git已经提示如何返回了，如果现在有个文件叫做test，我们git add test加入到了staged区，现在如果要返回，我们使用git reset HEAD test就可以取消暂存。在缓存区中的文件可能是new file,可能是modified的，我们都可以用上面的命令来取消暂存，如果是更改了已经提交过的文件，那么就使用git checkout -- filename来回滚。git提交之前是将暂存区的文件提交，所以任何文件都需要git add到暂存区才可被提交。

如果已经做了一次提交，但是发现这次提交得不完整，同时comments也写错了，我们可以用git commit --amend来重做，比如：
{% highlight bash %}
git commit -m 'initial commit'
git add forgotten_file
git commit --amend -m "new message"
{% endhighlight %}

上面我们只是完成了单个文件的错误拯救，如果你在一个工作区已经做了犯了太多的错了，你想遗弃掉所有更改，一般我们都是回到一个提交的最新版本，不过也可以回退到历史的任何一个版本，命令是 git reset --hard 766f，这个766f就是历史提交的一次指纹的前几位，git会自动匹配，如果不指定这个指纹，就回退到最新提交，回退之后会抹掉比回退版本新的所有更改，请谨慎。如果使用git revert 766f就是产生了一次新提交，同时把代码回退到了某个历史版本。

现在我们修改之前的a,b文件把每个文件的内容变为12，然后提交，提交完之后如果你想把某个文件恢复到很早以前的版本使用的命令式git checkout 82f5 some.file another.file，也就是指定指纹和文件列表，这样可以讲a,b文件还原为内容是1的版本。

现在代码已经提交了很多版本了，如果你想跳到某个历史版本去看看，可以用git checkout 82f5去定位提交点。

###比较
git diff命令用来做比较操作，如果单纯的敲入git diff，它会列出当前工作区的未加入缓存区的更改文件和最新版本的比较，如果需要查看缓存区中的更改用git diff --staged，要同时查看用git diff HEAD，也可以用git diff HEAD^2到更上一层，HEAD你可以理解当前分支的别名。

可以指定分支进行比较git diff master，如果要比较两个分支用git diff master..another，git diff master...another是用这两个分支的父分支和another进行比较。

另外可以指定目录来缩小比较范围git diff HEAD -- ./lib ，直接比较两个版本git diff 3103 a8d9

###分支
一个正规的项目必然是有很多分支的，比如发布分支，开发分支，新特性分支，各个分支又涉及到合并，git branch用来支持分支操作，git branch查看分支，如果要在当前创建一个分支用git branch dev,这样就得到了一个dev分支,分支创建好了需要切换过去用git checkout dev，如果要合并这两步操作用git checkout -b dev，也可以在某个提交点创建分支比如git branch dev 3103就从3103这个版本创建一个分支。

我们可以通过创建一个分支来做快速修复：
{% highlight bash %}
git checkout -b fixes 1b6d
git commit -a -m "Bug fixed"
git checkout master
git merge fixes
{% endhighlight %}

在做分支合并的时候，如果遇到了冲突，git会在文件中保存着冲突内容并用以些符号隔开，这个文件状态变为unmerged，我们需要手工解决这些冲突，解决完了再git add进暂存区。

由于git的分支模型太灵活，很有可能你就管理不过来了，可以用 git branch -d dev来删除分支,-d表示删除，-D是强制删除，如果要重命名就用-m，上面我们做了一个快速修复，现在fixes和master都指向了同一个提交对象，所以fixes可以被删除了。在分支列表里查看合并和未合并的分支用git branch --merged和git branch --no-merged。

切换分支的时候最好保持干净的工作区，也就是经常保持提交，不然你会收到git的阻止，不过git提供了stashing 和 commit amending来避免这个问题。

###远程git
目前我们只是在本地初始了一个版本库供自己研究学习，正式项目，我们是需要和别人共享的，那么这就需要远程git的知识了。
现在我们需要将版本库放到另一个机器上，其他人都从这个机器克隆版本库，由于需要传输数据，所以这就需要传输协议了。git支持四种协议，分别是本地，ssh,git,http/https，我们使用github的时候，经常用后面三种协议。如果不需要跨网络，我们可以用本地协议来远程git。

查看本地和远程：
{% highlight bash %}
git remote
git remote -v
git branch 
git branch -r
{% endhighlight %}

要将本地库添加到远程服务器：git  remote  add  origin  git://github.com/someone/another_project.git

如果有了一个远程库，我们就可以通过某种协议clone版本库，比如git clone http://example.com/gitproject.git，然后Git 会自动为你将此远程仓库命名为 origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作。

本地的master分支可以不断前进，但是origin/master会停留在原来的地方，因为它是不可更改的，唯一更改它的方法是和服务器同步，使用git fetch origin，这个时候origin/master就和服务器同步了，如果你希望把服务器的内容合并到本地master上，就要用git merge origin/master。 

如果要把本地的分支推送到远程使用git push origin 本地分支名：远程分支名。如果直接敲击git push，会默认推送到origin的master分支。

如果远程有个分支叫做dev，你希望删除它，语法是git push origin :dev
