---
layout: article
title: 胡思乱想
---
这是一个很大的主题，写代码这么久了，不成体系的就全部写到这里，它可能涉及到程序领域的各种乱七八糟，各位看官将就吧。哪天我要死了，我也看看这里到底写了些啥。

###从Intellij IDEA开始
在捷克，一个叫Sergey Dmitriev的人在2000年的时候创立一个软件公司叫JetBrains。这个公司生产了一款Java IDE叫IDEA，Sergey Dmitriev为什么要开发这个软件呢？因为他认为写java代码真TM累，或者写程序也真TM累，所以他要一个智能的IDE。他对程序的理解在如下这篇文章里
[LOP](https://www.jetbrains.com/mps/docs/Language_Oriented_Programming.pdf)
[中文翻译版LOP](http://blog.csdn.net/chelsea/article/details/290486)


1. 我们的编程还是太过于原始，程序员还是太累，解空间和问题空间不好匹配，类，方法，循环，条件，最原始的元素
2. general-purpose语言需要我们把高层的领域概念翻译为低层的编程语言特性，在最终的程序中，很多高度概括的视角、蓝图都丢失了
3. general-purpose语言不能搞定所有问题，任何复杂的系统都会有一个丑陋的lisp解析器，更不可能有通用dsl
4. 程序为什么非得时文本行，不能是其他结构吗？不能是图形吗？于是JetBrains开发了MPS


![JetBrains Product](/images/jet_product.png)

###如何在IDEA中快速编写Java代码

这里是Oh My IDEA这个插件的演示，敲代码的重点是敲，那么我们如果能够更少碰鼠标，那便是极好的。


###计算机机器的历史

算盘是什么原理？
![算盘](/images/suanpan.jpg)

我们的祖先把四则运算全部表达成了机械操作，你只要需要一个存储器，然后用一个机械的规则不断的修改存储器就可以完成计算了。那么数学还有必要研究吗？

![莱布尼兹](/images/lbnz.jpg)
我们从加减乘除到代数运算再到微积分，这些数学定理都是一种符号表示，那么是否可以给定一个规则，然后一个机械过程，自动推导出数学命题呢？


![布尔](/images/buer.jpg)
在不知道莱布尼兹的设想下，发现人类的逻辑是可以表示为代数运算


![弗雷格](/images/flg.jpg)
独立布尔，发展了概念文字，发现了编程语言的原型，用概念文字描述数学基础但是被罗素灭了


![康托尔](/images/kter.jpg)
挑战集合论，发现对角线法则

![希尔伯特](/images/xebt.jpg)
认为数学是的真理是可以用机器进行机械推导的，但是这个天真的想法被哥德尔否定了

![图灵](/images/tl.jpg)
图灵想证明为什么数学是不能机械推到的，发现了图灵计算模型，同时邱奇通过拉姆达函数可定义性也发现了。

![冯诺依曼](/images/fnym.jpg)
冯诺依曼放弃了研究逻辑，制造计算机，存储程序的革命


###斐波拉契和快速排序

图灵，描述步骤
{% highlight javascript %}
var position = 10; //位置
var fib = []; //存储

fib[0] = 0;fib[1] = 1;
for(i=2; i<=position; i++) {
    fib[i] = fib[i-2] + fib[i-1];
}

var result = fib[position]; //得到这个位置的Fibonacci数
{% endhighlight %}


申明式描述
{% highlight javascript %}
function fib(n){
  return n<2 ? n: fib(n-1)+fib(n-2);
}
var result = fib(10);
{% endhighlight %}


逻辑式描述
{% highlight javascript %}
rule FebCalculate
    when
        f1 : Fact( s1 : seq, value != -1 ) //如果有一个事实的值不是-1
        f2 : Fact( seq == (s1 + 1 ), value != -1 )  //如果后继事实值也不是-1
        f3 : Fact( s3 : seq == (f2.seq + 1 ), value == -1 )//如果再后继的事实的值是-1
    then
        modify ( f3 ) { value = f1.value + f2.value }; //则进行计算，将两个事实的值求和复制给第三个事实的value属性
end
{% endhighlight %}


图灵，修改内存
{% highlight java %}
public int partition(int[] array, int left, int right) {

        //假定第一个是基准
        int point = left;

        int compare = array[left];

        //从第二个开始向后看，如果发现比第一个小就要移动指针同时做交换
        for (int j = left + 1; j <= right; j++) {
            if (array[j] < compare) {
                point++;
                swap(array, point, j);
            }
        }

        //经过上述循环可能在其他地方找到了基准应该出现的位置,把第一个数交换到指针处
        swap(array, point, left);

        return point;
 }

{% endhighlight %}


为什么要修改数据呢？
{% highlight ruby %}
def quicksort a
  (pivot = a.pop) ? quicksort(a.select{|i| i < pivot}) + [pivot] + quicksort(a.select{|i| i > pivot}) : []
end
{% endhighlight %}


###程序员眼中的物理学




###相关书籍
1. 计算机程序构造与解释
2. 冒号课堂
3. 逻辑的引擎
4. 哥德尔，巴赫，埃舍尔
5. 超越时空

