---
layout: article
title: 我理解的正则表达式
---

时光回到高级编程语言刚开始产生，我们需要实现编译器来编译这些高级语言，于是词法结构开始约定，比如标识符的约定是开始字符只能是字母，下划线和$符号，其他字符可以是数字，字母，下划线和$符号，在识别这个标识符的时候我们在
字母，数字，下划线，$符号的有穷集合中通过机械的遍历这个字符串进行判定，这个过程是可以通过数学模型有穷自动机来实现的，生活中最简单的有穷自动机就是很多公司或者超市安装的感应门，它在开和闭两个状态之间切换，由于判断词法规则
就是一个很机械的语言识别过程，我们可以发明某种声明式的模式来描述词法，至于某种声明模式是否和某个语言或者字符串匹配就可以开发一个通用的算法程序了，每次解析一个声明就重用这个程序，这个声明模式就叫做正则表达式。

###匹配的本质
正则表达式就是用来匹配字符串的，而字符集合应该包括人类所创造的所有符号，目前unicode字符集是包括字符数量最广的，这些字符有些是可见的，比如字母和数字，有些则是不可见的，比如控制字符，但是每一个字符必须对应一个编号，不然就没办法
用计算机来处理了，所以要写一个正则表达式相当简单，直接写一串unicode的编码就是了，这是最直接的，比如我要匹配abc*，在js中我就写一个\u0061\u0062\u0063\u002a就可以了，这四个unicode编码分别对应abc*，正则表达式的字符如果连起来写
就表示与运算，它还可以表达或运算比如我要匹配a或者b，就用a|b，如果严格按照编程语言的写法，abc应该是a&&b&&c，a|b|c应该是a||b||c，因为正则表达式就是为了追求简洁所以就是现在这个写法，有了与和或运算，那有非运算吗？
比如我想表达非a，可以写成!a吗？正则表达式中用的不是感叹号而是^脱字符，这个^符号会把它后面的所有字符非掉，边界是中括号，所以表达非a的表达式是[^a]，表达非abc就是[^abc],而[abc]表示abc中的任意一个，所以[abc]和a|b|c等价。

***注意|运算的边界是很大的,yes|no表示的是yes或者no，不是表示s或者n，要表达s或者n要用yes(s|n)no，同时这个规则是从左到右选择匹配，如果存在交集以左为主，比如a|ab是匹配不到ab的***

###重复
通过上面的学习，我们知道了如何组合字符来表达与或非的运算，但是它不能表达一个字符重复多次的模式，重复可以视为和编程语言的控制结构类似的东西，如果重复有限次，比如10次，我们可以写aaaaaaaaaa，可是如果次数多了就傻眼了，在正则表达式中选择了大括号来{}来表达重复，
比如a重复1次到5次就写成a{1,5}，这种写法表达了一个区间，但是我们有时候需要表达恰好多少次，或者右区间是无限的，所以写法可以有{1}表示恰好一次，{1,}表示一次或任意次,通过这样的写法我们就可以表示任意的重复了。实战中
我们发现有些写法太常用了，比如{0,1},{1,},{0,}，每次都要写大括号，于是我们又把这三个重复分别用?,+,*代替了。

***注意重复的写法只控制左边最近的字符，比如ab{2}表示是b重复2次，如果要表达ab重复两次，必须用括号了，即写为：(ab){2}，括号在正则表达式中还表示其他用途，后面讲。***

###简写
现在我们发现写正则表达式大量的引入简写(前面的*,?,+,|)，这真的是程序员偷懒的本质，引入简写可以在有限的空间里面表达大量的信息，简写的本质是大大的利用那些标点符号，这可以解释perl语言程序为什么那么难读了，正则表达式写复杂了也是相当的难读。
那么正则表达式还有哪些间写呢？我们刚才用[abc]表达了匹配a或者b或者c，可是如果里面的字母多了就不好写了，于是表达字母和数字区间我们用[a-z][A-Z][0-9]来简化了，还不止，我们用.来表示除换行符之外的所有字符，\w简化了
所有ASCII的单字字符，\s简化了所有空白字符,\d简化了ASCII数字,这三个的大写形式表示了非运算。

前面我们说每一个字符都是有一个编码，有些编码表示的字符是不可见的，那么正则表达式如何表示这些字符呢？我们又有很多写法来表示它，\o表示\u0000,\t表示\u0009,\n表示\u000A,\v表示\u000B,\f表示\u000C,\r表示\u000D，当然对于
这些不可见字符，你完全可以用他的unicode编码来做匹配，有一部分unicode字符编码的前两个字节都是00，比如\u000A我们可以简写为\x0A，这种表示法之能表示拉丁字符，ASCII里面还有一些控制字符，我们用\c的方式表示。

###转义
原本我们可以直接用unicode编码来表示正则表达式的，但是为了简写和控制我们用了一些特殊符号，比如\,?,+,*,{,[，这种符号表达了特殊的意思，它已经不不表示这个符号本身了，如果需要表示符号本身有两种方法，一是用他的编码，而是在这个符号前写一个\，比如\的
真实意义可以用\\或者\u005C。

###贪婪
正则表达式在做重复匹配的时候，会尽可能匹配最长，也就是贪婪模式，比如http://www.google.com:8080，用.*:去匹配，匹配算法找到了第一个匹配之后觉得可能后面还有可以匹配，所以贪婪的继续往后匹配，一直到字符串最后，发现没有了才折回。
那么如果和控制匹配算法的贪婪欲望呢，在重复写法的后面加一个?即可，比如.*?:就可以得到http:的匹配。

###括号的二义性
前面我知道括号可以用来将多个字符作为一个整体看待，括号还有了另一个作用是表达子模式，通过子模式匹配到的内容可以在后方引用和提取，比如(.)\1就可以表示两个连续相同的字符，因为这项特性，匹配在遇到括号的时候内部会维护匹配
数据，效率可能降低，如果只是想用括号分组而不需要引用和提取，则可以用?:来提示匹配引擎不要维护数据，刚才的写法就变成(?:.)。

###指定匹配位置
目前为止我们写的任何一个表达式都会在整个字符串中匹配，比如abc在字符串abcdgewgaabcgegwgewgewabc中会成功匹配三次，可是有时候我们不需要这样匹配，我们可能希望只匹配开头或者结尾或者只匹配出单词，正则表达式中，我们用^脱字符来表示匹配开始
，注意这个符号在中括号中可以表达非运算，用$表示匹配结尾，用\b表示匹配单词，相反\B表示不匹配单词。对于位置的指定，我们可能还更加苛刻，比如请匹配abc，其后一定要是一个数字，但是又不匹配这个数字，这个时候就需要写成abc(?=\d)，也就是说表达式中有断言。

###总结
解析正则表达式目前有两种引擎，一是DFA，另一个是NFA，这两种引擎都有各自的特点，但是大部分工具都集合了这两种引擎来进行互补，假如你要实现一个正则表达式的解析程序，则必须研究这两种引擎，他们分别对应一个数学模型，确定性自动机和非确定自动机，
这两种自动机可以互相转换，正则表达式和这两种自动机等价，到这里我想到了lambda演算和图灵机，前者是声明式的，后者是机械式的，而他们表达的计算机能力是一样的，也就是说是等价的，同样正则表达式是声明式的，而自动机是机械式的，它们也是等价的，对于正则语言，它的
数学表述如下：

1. 闭包运算，运算优先级最高，(r)* 表示 (L(r))*

2. 连接运算，运算优先集合低于闭包，(r)(s) 表示 (L(r))(L(s))

3. 或运算，运算优先集合最低，(r) | (s) 表示 (L(r)) U (L(s))
