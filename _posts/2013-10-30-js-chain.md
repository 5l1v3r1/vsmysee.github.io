---
layout: article
title: JavaScript中的三个链条
---

JS是一个动态和弱类型语言，这两项特征造就了它的与众不同，用它写出的代码可以怪异得完全看不懂，也可以正经得跟Java一样，本文分析JS语言中的三个链条，个人认为理解了这三个链条基本上可以掌握这个语言的80%。

###第一链：原型对象
###第二链：构造函数
###第三链：作用域

前两个链条我们要在JS的面向对象中分析，而第三个链条我们在函数的执行原理中分析,注意JS中只有对象的概念，而对象又有一个原型的概念，原型其实也是一个对象，有人会说函数不是对象吧？错，函数也是一个对象，JS真是一个一切皆对象的
语言，对象就是一个key,value结构体，key是对象，value还是对象,所以对象本身就是一个对象树状图，JS中没有hashcode的概念，因为它的key全部必须为字符串对象，如果把一个非字符串对象作为key，那么执行引擎会自动调用对象的toString方法。

那么对象怎么来？有些是浏览器或者引擎内置的，比如window,Object,一般情况下的对象有两种方式产生，一种通过直接量，比如var o = {}，另一种通过new关键字加上一个函数对象，比如var o = new Object()，这个new类似Java语言的实例化对象，但是JS中没有类。每个对象都有一个原型对象和它关联，
内部机制是在每个对象内部有一个_proto_属性指向自己的原型，这个属性是只读的，不过IE的js引擎访问不到。
一个新生对象是如何关联到自己的原型的呢？就在new的时候，new的过程是，引擎先创建了一个非常干净的对象，其实这个时候我觉得不应该叫做对象，叫它内存块更合适，然后让这个干净对象作为this去调用new后面的那个函数，函数中可以用this访问这个干净对象并对它进行初始化，最后引擎把函数对象上的原型对象介绍给那个干净对象，这样干净对象就和原型
关联起来了。

所以一般对象有一个_proto_属性，而函数对象除了有_proto_属性还有一个prototype属性，这个属性用来new对象的时候介绍给新对象的。

代码演示
{% highlight javascript %}
//这是两种得到对象的方法，但是背后的机制都一样
var o1 = {};
var o2 = new Object();

var Plane = function(x,y) {
    //this是调用这个函数的那个干净对象
    this.x = x;
    this.y = y;
}

//类似java中的对象实例化
var p = new Plane(2,3);
//这时候对象上有属性了
alert(p.x);

//_proto_指向函数的prototype
alert(p.__proto__ == Plane.prototype);
alert(Plane.prototype.__proto__ == Object.prototype);
{% endhighlight %}

借用标准面向对象的说法，我们把和new一起进行造对象的那个函数对象叫做构造函数，js中所有函数在定义的时候都会被自动的初始化一个原型，构造函数做两件事情，一是初始化，二是介绍自己prototype属性引用的对象给新对象。由此我们得到了第一条链，原型链，就拿上面的代码来说p的原型指向Plane的原型，Plane的原型本身也是
一个对象，它由Object函数构造出来，那么它就指向Object函数的原型，Object函数的原型是链条的顶端，Object的原型的_proto_是空的，也就表明链条终结于此,现在链条上只有两个原型对象，等会我们来实现继承的时候会加入更多的原型。那么有人会问，Object函数所关联的那个原型是哪个函数构造的，这个我不知道,它的_proto_为null，只能说明没有函数构造它，它是上帝创造的。
维护了链条的作用是用来做属性查找，对象的属性访问如果对象自身没有就沿着链条搜索直到object.prototype。
{% highlight javascript %}
alert(Object.prototype.__proto__); //在chrome中打印null
{% endhighlight %}


JS的每一个对象都有一个constructor属性，这个属性指向构造这个对象的构造函数，按照我们的例子var p = new Plane(2,3)，p.constructor指向Plane这个构造函数，那么constructor是谁的属性？是p的吗？不是，它是属于p.__proto__的
因为p.__proto__是某个函数关联的对象，很自然，这个对象又用constructor指回到这个函数，也就是说，引擎在给函数创建prototype对象的时候设置了一个constructor属性指向了这个函数，由于函数也是对象，所以也可以写出p.constructor.constructor这样的代码，它的值是Function函数，下面的代码都为true:
{% highlight javascript %}
alert(Object.prototype.constructor == Object);
alert("".constructor == String);
alert("".constructor.constructor == Function);
alert(String.constructor == Function);
alert(Object.constructor == Function);
{% endhighlight %}

那么Function.constructor是哪个函数？通过测试我们发现它的值是Function，Function是个对象，它的构造函数居然是它自己，那么Function.constructor.constructor.constructor == Function的值也是true，我的个神啊！
由此，我们又得到了第二条链，构造函数链，p.constructor指向Plane,Plane.prototype.__proto__ .constructor指向Object，只不过这个链条似乎是嫁接在原型上的，迂回上升。在IE中，我们不能访问__proto__属性，现在
我们可以通过o.constructor.prototype直接访问到一个对象的原型了，找来一张图，大家看看，图中的Foo是一个自定函数，类似本文的Plane。
![js原型](/images/prototype.png)


搞清楚了JS的原型和构造器链条，我们就可以来研究如何和在JS中实现继承层次了，在Java这种语言中，我们用extends不断的把类连起来就可以了，但是在JS中必须要照顾好这两个链条，不然继承就可能出问题。

#待续.....





